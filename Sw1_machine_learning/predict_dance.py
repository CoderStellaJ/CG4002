from joblib import dump, load # to load ML
import numpy # to count labels and store in dict
import operator # to get most predicted label

# REPLACE DICT WITH DICT FROM SENSOR
# dumbbell data - unlabeled, try to predict
dic_data = {'1C:BA:8C:1D:30:22': {1: [7550, 135.56, -23.01, 35.82], 2: [7550, 134.85, -23.41, 35.39], 3: [7550, 133.97, -23.91, 34.99], 4: [7550, 132.94, -24.46, 34.63], 5: [7550, 131.95, -24.95, 34.31], 9: [7550, 129.88, -25.76, 33.42], 10: [7550, 129.47, -25.81, 33.13], 11: [7550, 129.11, -25.83, 32.85], 12: [7550, 133.53, -12.1, 26.13], 13: [7550, 133.87, -11.52, 26.08], 14: [7550, 134.19, -11.01, 26.04], 15: [7550, 134.5, -10.54, 26.01], 16: [7550, 134.78, -10.1, 25.94], 17: [7550, 135.03, -9.74, 25.85], 21: [7550, 136.07, -8.47, 25.71], 22: [7550, 136.57, -7.68, 25.68], 23: [7550, 141.19, -6.62, 24.69], 24: [7550, 141.26, -6.84, 24.64], 25: [7550, 141.32, -7.02, 24.57], 26: [7550, 141.36, -7.22, 24.52], 27: [7550, 141.38, -7.51, 24.48], 28: [7550, 141.35, -7.98, 24.43], 29: [7550, 141.33, -8.42, 24.37], 30: [7550, 141.32, -8.74, 24.3], 31: [7550, 141.37, -8.92, 24.22], 32: [7550, 141.43, -9.01, 24.13], 33: [7550, 133.44, -25.17, 20.59], 34: [7550, 133.02, -25.36, 20.61], 35: [7550, 132.59, -25.51, 20.63], 36: [7550, 132.28, -25.47, 20.67], 37: [7550, 132.18, -25.11, 20.75], 38: [7550, 132.19, -24.59, 20.82], 39: [7550, 132.2, -24.11, 20.85], 40: [7550, 132.14, -23.73, 20.82], 41: [7550, 132.06, -23.46, 20.8], 42: [7550, 131.96, -23.21, 20.8], 43: [7550, 131.77, -15.22, 19.64], 44: [7550, 132.7, -13.29, 19.53], 45: [7550, 133.55, -11.43, 19.43], 46: [7550, 134.2, -9.85, 19.34], 47: [7550, 134.69, -8.58, 19.23], 48: [7550, 135.1, -7.49, 19.15], 49: [7550, 135.51, -6.57, 19.19], 50: [7550, 135.93, -5.72, 19.31], 51: [7550, 136.32, -4.95, 19.49]}, '78:DB:2F:BF:3B:54': {1: [18263, -22.99, -18.39, -9.93], 2: [18263, -22.74, -16.68, -9.05], 3: [18263, -22.83, -15.6, -8.38], 4: [18263, -23.52, -15.1, -7.33], 5: [18263, -24.34, -14.85, -5.54], 6: [18263, -24.86, -14.95, -3.57], 7: [18263, -25.01, -15.04, -1.54], 8: [18263, -25.11, -14.73, 0.91], 9: [18263, -25.38, -14.37, 3.91], 10: [18263, -25.74, -14.47, 7.19], 11: [18263, -18.5, -9.48, 22.63], 12: [18263, -19.69, -9.4, 17.75], 13: [18263, -20.8, -9.15, 12.94], 14: [18263, -21.79, -9.3, 8.14], 15: [18263, -22.58, -10.5, 3.1], 16: [18263, -23.17, -12.35, -1.85], 17: [18263, -23.27, -13.32, -5.93], 18: [18263, -23.25, -13.25, -9.25], 19: [18263, -23.35, -13.18, -12.22], 20: [18263, -23.47, -13.27, -14.91], 21: [18263, -16.74, 0.04, 48.47], 22: [18263, -16.25, 0.53, 49.71], 23: [18263, -16.07, 0.65, 50.09], 24: [18263, -16.12, 0.5, 49.94], 25: [18263, -16.15, 0.05, 49.59], 26: [18263, -16.1, -0.68, 49.02], 27: [18263, -16.14, -1.6, 47.94], 28: [18263, -16.37, -2.6, 46.15], 29: [18263, -16.79, -3.5, 43.71], 30: [18263, -17.27, -4.19, 40.83], 31: [18263, -20.01, -0.1, -0.15], 32: [18263, -20.14, -0.27, 3.71], 33: [18263, -20.24, -0.17, 7.66], 34: [18263, -20.43, 0.0, 11.63], 35: [18263, -20.76, 0.27, 15.84], 36: [18263, -21.05, 0.68, 20.37], 37: [18263, -21.16, 1.04, 24.85], 38: [18263, -21.15, 1.29, 28.99], 39: [18263, -21.07, 1.52, 32.73], 40: [18263, -21.02, 1.71, 36.19], 41: [18263, -19.17, 4.38, -19.29], 42: [18263, -17.99, 4.69, -21.75], 43: [18263, -17.91, 5.53, -23.31], 44: [18263, -18.76, 6.25, -23.93], 45: [18263, -19.39, 6.5, -23.91], 46: [18263, -19.33, 6.03, -23.84], 47: [18263, -18.97, 4.94, -23.68], 48: [18263, -18.95, 3.78, -23.08], 49: [18263, -19.51, 2.9, -21.74], 50: [18263, -20.28, 2.33, -19.97]}}

leg = "1C:BA:8C:1D:30:22"
hand = "78:DB:2F:BF:3B:54"

# returns a list of lists, each list containing a row of sensor data
def parse_hand_data(dic_data):

    # collect hand data
    data = []

    for k,v in dic_data[hand].items(): # k = data point no, v = data collected
        ypr = [] # yaw, pitch, roll
        for i in range(1,4):
            ypr.append(v[i])
        data.append(ypr)

    return(data)

# Get list of lists of yaw, pitch, roll data from data dict
ypr_data = parse_hand_data(dic_data)
# print(ypr_data)

# Load KNN model
knn = load('knn_dance.joblib')

# Get Predictions
y_pred = knn.predict(ypr_data)
# print(y_pred)
# print(len(y_pred))

# Get counts of predictions stored in dictionary
unique, counts = numpy.unique(y_pred, return_counts=True)
y_pred_count = dict(zip(unique, counts))
# print(y_pred_count)

# Get the dance label that was predicted the most
prediction = max(y_pred_count.items(), key=operator.itemgetter(1))[0]
# print(prediction)




